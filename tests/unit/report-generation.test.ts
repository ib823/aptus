/**
 * Phase 7: Report Generation — Unit Tests
 *
 * Tests XLSX sheet configs, flow diagram SVG generation,
 * PDF generators, report summary computation, and remaining items logic.
 */

import { describe, it, expect } from "vitest";

// ===========================================================================
// XLSX Sheet Config Tests
// ===========================================================================

interface SheetConfig {
  name: string;
  columns: Array<{ header: string; key: string; width: number }>;
  rows: Array<Record<string, unknown>>;
}

function scopeCatalogSheet(data: Array<Record<string, unknown>>): SheetConfig {
  return {
    name: "Scope Catalog",
    columns: [
      { header: "Scope Item ID", key: "scopeItemId", width: 15 },
      { header: "Name", key: "name", width: 35 },
      { header: "Functional Area", key: "functionalArea", width: 20 },
      { header: "Sub Area", key: "subArea", width: 20 },
      { header: "Selected", key: "selected", width: 10 },
      { header: "Relevance", key: "relevance", width: 12 },
      { header: "Current State", key: "currentState", width: 15 },
      { header: "Notes", key: "notes", width: 40 },
      { header: "Total Steps", key: "totalSteps", width: 12 },
      { header: "Config Count", key: "configCount", width: 12 },
    ],
    rows: data,
  };
}

function gapRegisterSheet(data: Array<Record<string, unknown>>): SheetConfig {
  return {
    name: "Gap Register",
    columns: [
      { header: "Gap ID", key: "gapId", width: 25 },
      { header: "Scope Item", key: "scopeItem", width: 15 },
      { header: "Gap Description", key: "gapDescription", width: 40 },
      { header: "Resolution Type", key: "resolutionType", width: 18 },
      { header: "Effort Days", key: "effortDays", width: 12 },
      { header: "Risk Level", key: "riskLevel", width: 12 },
      { header: "Client Approved", key: "clientApproved", width: 15 },
    ],
    rows: data,
  };
}

function remainingItemsSheet(data: Array<Record<string, unknown>>): SheetConfig {
  return {
    name: "Remaining Items",
    columns: [
      { header: "Item #", key: "itemNumber", width: 10 },
      { header: "Category", key: "category", width: 25 },
      { header: "Title", key: "title", width: 35 },
      { header: "Severity", key: "severity", width: 12 },
      { header: "Functional Area", key: "functionalArea", width: 20 },
      { header: "Auto-Generated", key: "autoGenerated", width: 15 },
    ],
    rows: data,
  };
}

describe("XLSX Sheet Configs", () => {
  it("should create scope catalog sheet with correct structure", () => {
    const data = [
      { scopeItemId: "J60", name: "Accounts Payable", functionalArea: "Finance", selected: "Yes", relevance: "IN_SCOPE" },
    ];
    const sheet = scopeCatalogSheet(data);

    expect(sheet.name).toBe("Scope Catalog");
    expect(sheet.columns).toHaveLength(10);
    expect(sheet.columns[0]?.header).toBe("Scope Item ID");
    expect(sheet.rows).toEqual(data);
  });

  it("should create gap register sheet", () => {
    const data = [
      { gapId: "gap-1", scopeItem: "J60", gapDescription: "Missing feature", resolutionType: "WORKAROUND", effortDays: 5 },
    ];
    const sheet = gapRegisterSheet(data);

    expect(sheet.name).toBe("Gap Register");
    expect(sheet.columns).toHaveLength(7);
    expect(sheet.rows).toEqual(data);
  });

  it("should create remaining items sheet", () => {
    const data = [
      { itemNumber: 1, category: "unreviewed_step", title: "Unreviewed: Step A", severity: "medium" },
    ];
    const sheet = remainingItemsSheet(data);

    expect(sheet.name).toBe("Remaining Items");
    expect(sheet.columns).toHaveLength(6);
    expect(sheet.rows).toEqual(data);
  });

  it("should handle empty data arrays", () => {
    const sheet = scopeCatalogSheet([]);
    expect(sheet.rows).toHaveLength(0);
    expect(sheet.columns.length).toBeGreaterThan(0);
  });
});

// ===========================================================================
// Flow Diagram SVG Generation Tests
// ===========================================================================

const STATUS_COLORS: Record<string, { fill: string; stroke: string; text: string }> = {
  FIT: { fill: "#dcfce7", stroke: "#16a34a", text: "#15803d" },
  CONFIGURE: { fill: "#dbeafe", stroke: "#2563eb", text: "#1d4ed8" },
  GAP: { fill: "#fef3c7", stroke: "#d97706", text: "#b45309" },
  NA: { fill: "#f3f4f6", stroke: "#9ca3af", text: "#6b7280" },
  PENDING: { fill: "#f3f4f6", stroke: "#d1d5db", text: "#9ca3af" },
};

interface FlowStep {
  id: string;
  sequence: number;
  actionTitle: string;
  stepType: string;
  fitStatus: string;
}

function escapeXml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

function generateFlowSvg(flowName: string, scopeItemName: string, steps: FlowStep[]): string {
  const nodeWidth = 180;
  const nodeHeight = 50;
  const gapX = 40;
  const gapY = 20;
  const nodesPerRow = 4;
  const padding = 30;
  const headerHeight = 60;

  const rows = Math.ceil(steps.length / nodesPerRow);
  const svgWidth = padding * 2 + nodesPerRow * nodeWidth + (nodesPerRow - 1) * gapX;
  const svgHeight = padding + headerHeight + rows * (nodeHeight + gapY) + padding;

  const parts: string[] = [];
  parts.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}">`);
  parts.push(`<style>text { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }</style>`);
  parts.push(`<rect width="100%" height="100%" fill="white"/>`);
  parts.push(`<text x="${padding}" y="${padding + 16}" font-size="14" font-weight="bold" fill="#111827">${escapeXml(scopeItemName)}</text>`);
  parts.push(`<text x="${padding}" y="${padding + 34}" font-size="11" fill="#6b7280">${escapeXml(flowName)}</text>`);

  for (let i = 0; i < steps.length; i++) {
    const step = steps[i];
    if (!step) continue;
    const col = i % nodesPerRow;
    const row = Math.floor(i / nodesPerRow);
    const x = padding + col * (nodeWidth + gapX);
    const y = padding + headerHeight + row * (nodeHeight + gapY);
    const colors = STATUS_COLORS[step.fitStatus] ?? STATUS_COLORS["PENDING"];
    if (!colors) continue;
    parts.push(`<rect x="${x}" y="${y}" width="${nodeWidth}" height="${nodeHeight}" rx="6" fill="${colors.fill}" stroke="${colors.stroke}" stroke-width="1.5"/>`);
    const title = step.actionTitle.length > 22 ? step.actionTitle.slice(0, 22) + "…" : step.actionTitle;
    parts.push(`<text x="${x + 8}" y="${y + 30}" font-size="10" fill="#111827">${escapeXml(title)}</text>`);
  }

  parts.push("</svg>");
  return parts.join("\n");
}

describe("Flow Diagram SVG Generation", () => {
  const makeStep = (overrides: Partial<FlowStep> = {}): FlowStep => ({
    id: overrides.id ?? `step-${Math.random().toString(36).slice(2, 8)}`,
    sequence: overrides.sequence ?? 1,
    actionTitle: overrides.actionTitle ?? "Test Step",
    stepType: overrides.stepType ?? "Process Step",
    fitStatus: overrides.fitStatus ?? "FIT",
  });

  it("should generate valid SVG markup", () => {
    const svg = generateFlowSvg("Main Flow", "Accounts Payable", [makeStep()]);
    expect(svg).toContain("<svg");
    expect(svg).toContain("</svg>");
    expect(svg).toContain("Accounts Payable");
    expect(svg).toContain("Main Flow");
  });

  it("should color FIT nodes green", () => {
    const svg = generateFlowSvg("Flow", "Scope", [makeStep({ fitStatus: "FIT" })]);
    expect(svg).toContain(STATUS_COLORS["FIT"]!.fill);
    expect(svg).toContain(STATUS_COLORS["FIT"]!.stroke);
  });

  it("should color GAP nodes amber", () => {
    const svg = generateFlowSvg("Flow", "Scope", [makeStep({ fitStatus: "GAP" })]);
    expect(svg).toContain(STATUS_COLORS["GAP"]!.fill);
    expect(svg).toContain(STATUS_COLORS["GAP"]!.stroke);
  });

  it("should color CONFIGURE nodes blue", () => {
    const svg = generateFlowSvg("Flow", "Scope", [makeStep({ fitStatus: "CONFIGURE" })]);
    expect(svg).toContain(STATUS_COLORS["CONFIGURE"]!.fill);
  });

  it("should handle NA and PENDING statuses", () => {
    const steps = [
      makeStep({ fitStatus: "NA", sequence: 1 }),
      makeStep({ fitStatus: "PENDING", sequence: 2 }),
    ];
    const svg = generateFlowSvg("Flow", "Scope", steps);
    expect(svg).toContain(STATUS_COLORS["NA"]!.fill);
    expect(svg).toContain(STATUS_COLORS["PENDING"]!.stroke);
  });

  it("should truncate long action titles", () => {
    const svg = generateFlowSvg("Flow", "Scope", [
      makeStep({ actionTitle: "This is a very long action title that exceeds the limit" }),
    ]);
    expect(svg).toContain("This is a very long ac…");
  });

  it("should handle multiple rows of nodes", () => {
    const steps = Array.from({ length: 6 }, (_, i) =>
      makeStep({ sequence: i + 1, actionTitle: `Step ${i + 1}` }),
    );
    const svg = generateFlowSvg("Flow", "Scope", steps);
    // 6 steps = 2 rows (4 per row)
    const rectCount = (svg.match(/<rect.*?rx="6"/g) ?? []).length;
    expect(rectCount).toBe(6);
  });

  it("should escape XML special characters", () => {
    const svg = generateFlowSvg("A & B <Flow>", "Scope \"test\"", [
      makeStep({ actionTitle: "Step <1> & 'more'" }),
    ]);
    expect(svg).toContain("A &amp; B &lt;Flow&gt;");
    expect(svg).toContain("Scope &quot;test&quot;");
  });

  it("should handle empty steps array", () => {
    const svg = generateFlowSvg("Empty Flow", "Scope", []);
    expect(svg).toContain("<svg");
    expect(svg).toContain("</svg>");
    expect(svg).toContain("Empty Flow");
  });

  it("should set appropriate SVG dimensions", () => {
    const svg = generateFlowSvg("Flow", "Scope", [makeStep()]);
    const widthMatch = svg.match(/width="(\d+)"/);
    const heightMatch = svg.match(/height="(\d+)"/);
    expect(widthMatch).not.toBeNull();
    expect(heightMatch).not.toBeNull();
    expect(Number(widthMatch?.[1])).toBeGreaterThan(0);
    expect(Number(heightMatch?.[1])).toBeGreaterThan(0);
  });
});

// ===========================================================================
// Report Summary Computation Tests
// ===========================================================================

interface ReportSummary {
  scope: { total: number; selected: number; maybe: number };
  steps: {
    total: number; reviewed: number; pending: number;
    fit: number; configure: number; gap: number; na: number; fitPercent: number;
  };
  gaps: {
    total: number; resolved: number; pending: number;
    totalEffortDays: number; byType: Record<string, number>;
  };
}

function computeReportSummary(
  scopeSelections: Array<{ selected: boolean; relevance: string }>,
  stepResponses: Array<{ fitStatus: string }>,
  totalProcessSteps: number,
  gaps: Array<{ resolutionType: string; effortDays: number | null }>,
): ReportSummary {
  const selectedCount = scopeSelections.filter((s) => s.selected).length;
  const maybeCount = scopeSelections.filter((s) => s.relevance === "MAYBE").length;

  const fitCount = stepResponses.filter((s) => s.fitStatus === "FIT").length;
  const configureCount = stepResponses.filter((s) => s.fitStatus === "CONFIGURE").length;
  const gapCount = stepResponses.filter((s) => s.fitStatus === "GAP").length;
  const naCount = stepResponses.filter((s) => s.fitStatus === "NA").length;
  const fitPercent = totalProcessSteps > 0
    ? Math.round(((fitCount + configureCount) / totalProcessSteps) * 100)
    : 0;

  const totalEffortDays = gaps.reduce((sum, g) => sum + (g.effortDays ?? 0), 0);
  const resolvedGaps = gaps.filter((g) => g.resolutionType !== "PENDING").length;
  const byType: Record<string, number> = {};
  for (const g of gaps) {
    byType[g.resolutionType] = (byType[g.resolutionType] ?? 0) + 1;
  }

  return {
    scope: { total: scopeSelections.length, selected: selectedCount, maybe: maybeCount },
    steps: {
      total: totalProcessSteps,
      reviewed: stepResponses.length,
      pending: totalProcessSteps - stepResponses.length,
      fit: fitCount,
      configure: configureCount,
      gap: gapCount,
      na: naCount,
      fitPercent,
    },
    gaps: {
      total: gaps.length,
      resolved: resolvedGaps,
      pending: gaps.length - resolvedGaps,
      totalEffortDays,
      byType,
    },
  };
}

describe("Report Summary Computation", () => {
  it("should compute correct scope stats", () => {
    const scopes = [
      { selected: true, relevance: "IN_SCOPE" },
      { selected: true, relevance: "IN_SCOPE" },
      { selected: false, relevance: "MAYBE" },
      { selected: false, relevance: "OUT_OF_SCOPE" },
    ];
    const summary = computeReportSummary(scopes, [], 0, []);
    expect(summary.scope.total).toBe(4);
    expect(summary.scope.selected).toBe(2);
    expect(summary.scope.maybe).toBe(1);
  });

  it("should compute correct step statistics", () => {
    const responses = [
      { fitStatus: "FIT" },
      { fitStatus: "FIT" },
      { fitStatus: "CONFIGURE" },
      { fitStatus: "GAP" },
      { fitStatus: "NA" },
    ];
    const summary = computeReportSummary([], responses, 10, []);
    expect(summary.steps.reviewed).toBe(5);
    expect(summary.steps.pending).toBe(5);
    expect(summary.steps.fit).toBe(2);
    expect(summary.steps.configure).toBe(1);
    expect(summary.steps.gap).toBe(1);
    expect(summary.steps.na).toBe(1);
    expect(summary.steps.fitPercent).toBe(30); // (2+1)/10 * 100
  });

  it("should compute fit percent as 0 when no steps", () => {
    const summary = computeReportSummary([], [], 0, []);
    expect(summary.steps.fitPercent).toBe(0);
  });

  it("should compute gap statistics", () => {
    const gaps = [
      { resolutionType: "WORKAROUND", effortDays: 5 },
      { resolutionType: "CUSTOMIZATION", effortDays: 10 },
      { resolutionType: "PENDING", effortDays: null },
      { resolutionType: "WORKAROUND", effortDays: 3 },
    ];
    const summary = computeReportSummary([], [], 0, gaps);
    expect(summary.gaps.total).toBe(4);
    expect(summary.gaps.resolved).toBe(3); // 4 - 1 PENDING
    expect(summary.gaps.pending).toBe(1);
    expect(summary.gaps.totalEffortDays).toBe(18);
    expect(summary.gaps.byType["WORKAROUND"]).toBe(2);
    expect(summary.gaps.byType["CUSTOMIZATION"]).toBe(1);
    expect(summary.gaps.byType["PENDING"]).toBe(1);
  });

  it("should handle null effort days", () => {
    const gaps = [
      { resolutionType: "WORKAROUND", effortDays: null },
      { resolutionType: "WORKAROUND", effortDays: null },
    ];
    const summary = computeReportSummary([], [], 0, gaps);
    expect(summary.gaps.totalEffortDays).toBe(0);
  });
});

// ===========================================================================
// Remaining Items Logic Tests
// ===========================================================================

interface RemainingItem {
  id: string;
  category: string;
  title: string;
  severity: string;
  resolvedAt: string | null;
  autoGenerated: boolean;
}

function computeRemainingItemsSummary(items: RemainingItem[]) {
  const bySeverity: Record<string, number> = {};
  const byCategory: Record<string, number> = {};
  let resolved = 0;
  for (const item of items) {
    bySeverity[item.severity] = (bySeverity[item.severity] ?? 0) + 1;
    byCategory[item.category] = (byCategory[item.category] ?? 0) + 1;
    if (item.resolvedAt) resolved++;
  }
  return {
    total: items.length,
    bySeverity,
    byCategory,
    resolved,
    unresolved: items.length - resolved,
  };
}

const CATEGORY_LABELS: Record<string, string> = {
  unreviewed_step: "Unreviewed Step",
  maybe_scope: "Undecided Scope",
  excluded_recommended_config: "Excluded Config",
  out_of_scope_gap: "Deferred Gap",
  integration_point: "Integration Point",
  data_migration: "Data Migration",
  custom_requirement: "Custom Requirement",
};

function filterRemainingItems(
  items: RemainingItem[],
  filters: { category?: string; severity?: string; resolved?: string; search?: string },
): RemainingItem[] {
  let result = items;
  if (filters.category && filters.category !== "all") {
    result = result.filter((i) => i.category === filters.category);
  }
  if (filters.severity && filters.severity !== "all") {
    result = result.filter((i) => i.severity === filters.severity);
  }
  if (filters.resolved === "resolved") {
    result = result.filter((i) => i.resolvedAt !== null);
  } else if (filters.resolved === "unresolved") {
    result = result.filter((i) => i.resolvedAt === null);
  }
  if (filters.search?.trim()) {
    const term = filters.search.toLowerCase();
    result = result.filter((i) => i.title.toLowerCase().includes(term));
  }
  return result;
}

function makeItem(overrides: Partial<RemainingItem> = {}): RemainingItem {
  return {
    id: overrides.id ?? `item-${Math.random().toString(36).slice(2, 8)}`,
    category: overrides.category ?? "custom_requirement",
    title: overrides.title ?? "Test item",
    severity: overrides.severity ?? "medium",
    resolvedAt: overrides.resolvedAt ?? null,
    autoGenerated: overrides.autoGenerated ?? false,
  };
}

describe("Remaining Items Summary", () => {
  it("should compute summary by severity", () => {
    const items = [
      makeItem({ severity: "critical" }),
      makeItem({ severity: "critical" }),
      makeItem({ severity: "high" }),
      makeItem({ severity: "medium" }),
    ];
    const summary = computeRemainingItemsSummary(items);
    expect(summary.total).toBe(4);
    expect(summary.bySeverity["critical"]).toBe(2);
    expect(summary.bySeverity["high"]).toBe(1);
    expect(summary.bySeverity["medium"]).toBe(1);
  });

  it("should compute summary by category", () => {
    const items = [
      makeItem({ category: "unreviewed_step" }),
      makeItem({ category: "unreviewed_step" }),
      makeItem({ category: "maybe_scope" }),
    ];
    const summary = computeRemainingItemsSummary(items);
    expect(summary.byCategory["unreviewed_step"]).toBe(2);
    expect(summary.byCategory["maybe_scope"]).toBe(1);
  });

  it("should count resolved vs unresolved", () => {
    const items = [
      makeItem({ resolvedAt: "2024-01-01T00:00:00Z" }),
      makeItem({ resolvedAt: null }),
      makeItem({ resolvedAt: null }),
    ];
    const summary = computeRemainingItemsSummary(items);
    expect(summary.resolved).toBe(1);
    expect(summary.unresolved).toBe(2);
  });

  it("should handle empty items array", () => {
    const summary = computeRemainingItemsSummary([]);
    expect(summary.total).toBe(0);
    expect(summary.resolved).toBe(0);
    expect(summary.unresolved).toBe(0);
  });
});

describe("Remaining Items Filtering", () => {
  const items = [
    makeItem({ category: "unreviewed_step", severity: "critical", title: "Unreviewed: AP step", resolvedAt: null }),
    makeItem({ category: "maybe_scope", severity: "high", title: "Undecided: GL module", resolvedAt: null }),
    makeItem({ category: "out_of_scope_gap", severity: "medium", title: "Deferred: Custom report", resolvedAt: "2024-01-01T00:00:00Z" }),
    makeItem({ category: "custom_requirement", severity: "low", title: "Integration: SAP CRM", resolvedAt: null }),
  ];

  it("should filter by category", () => {
    const result = filterRemainingItems(items, { category: "unreviewed_step" });
    expect(result).toHaveLength(1);
    expect(result[0]?.category).toBe("unreviewed_step");
  });

  it("should filter by severity", () => {
    const result = filterRemainingItems(items, { severity: "critical" });
    expect(result).toHaveLength(1);
    expect(result[0]?.severity).toBe("critical");
  });

  it("should filter by resolved status", () => {
    const resolved = filterRemainingItems(items, { resolved: "resolved" });
    expect(resolved).toHaveLength(1);
    const unresolved = filterRemainingItems(items, { resolved: "unresolved" });
    expect(unresolved).toHaveLength(3);
  });

  it("should filter by search term", () => {
    const result = filterRemainingItems(items, { search: "GL module" });
    expect(result).toHaveLength(1);
    expect(result[0]?.title).toContain("GL module");
  });

  it("should combine multiple filters", () => {
    const result = filterRemainingItems(items, {
      resolved: "unresolved",
      severity: "high",
    });
    expect(result).toHaveLength(1);
    expect(result[0]?.title).toContain("GL module");
  });

  it("should return all items when no filters applied", () => {
    const result = filterRemainingItems(items, {});
    expect(result).toHaveLength(4);
  });

  it("should handle 'all' as no-filter value", () => {
    const result = filterRemainingItems(items, { category: "all", severity: "all" });
    expect(result).toHaveLength(4);
  });
});

describe("Category Labels", () => {
  it("should have labels for all auto-generate categories", () => {
    const autoCategories = ["unreviewed_step", "maybe_scope", "excluded_recommended_config", "out_of_scope_gap"];
    for (const cat of autoCategories) {
      expect(CATEGORY_LABELS[cat]).toBeDefined();
      expect(CATEGORY_LABELS[cat]?.length).toBeGreaterThan(0);
    }
  });

  it("should have labels for manual categories", () => {
    const manualCategories = ["integration_point", "data_migration", "custom_requirement"];
    for (const cat of manualCategories) {
      expect(CATEGORY_LABELS[cat]).toBeDefined();
    }
  });
});

// ===========================================================================
// Sign-Off Logic Tests
// ===========================================================================

const SIGNOFF_ROLES = ["client_representative", "bound_consultant", "bound_pm"] as const;

function isAllSignedOff(signOffs: Array<{ signatoryRole: string }>): boolean {
  const signedRoles = new Set(signOffs.map((s) => s.signatoryRole));
  return SIGNOFF_ROLES.every((role) => signedRoles.has(role));
}

describe("Sign-Off Logic", () => {
  it("should require all three roles for complete sign-off", () => {
    const partial = [
      { signatoryRole: "client_representative" },
      { signatoryRole: "bound_consultant" },
    ];
    expect(isAllSignedOff(partial)).toBe(false);
  });

  it("should detect complete sign-off", () => {
    const complete = [
      { signatoryRole: "client_representative" },
      { signatoryRole: "bound_consultant" },
      { signatoryRole: "bound_pm" },
    ];
    expect(isAllSignedOff(complete)).toBe(true);
  });

  it("should handle empty sign-offs", () => {
    expect(isAllSignedOff([])).toBe(false);
  });

  it("should ignore duplicate roles", () => {
    const withDupe = [
      { signatoryRole: "client_representative" },
      { signatoryRole: "client_representative" },
      { signatoryRole: "bound_consultant" },
    ];
    expect(isAllSignedOff(withDupe)).toBe(false);
  });
});

// ===========================================================================
// Report Availability Tests
// ===========================================================================

describe("Report Availability", () => {
  const isReportAvailable = (status: string, reportKey: string): boolean => {
    const canGenerate = status === "completed" || status === "reviewed" || status === "signed_off";
    const isAuditTrail = reportKey === "audit-trail";
    return canGenerate || isAuditTrail;
  };

  it("should allow all reports for completed assessment", () => {
    expect(isReportAvailable("completed", "executive-summary")).toBe(true);
    expect(isReportAvailable("completed", "gap-register")).toBe(true);
    expect(isReportAvailable("completed", "audit-trail")).toBe(true);
  });

  it("should allow all reports for reviewed assessment", () => {
    expect(isReportAvailable("reviewed", "executive-summary")).toBe(true);
  });

  it("should allow all reports for signed-off assessment", () => {
    expect(isReportAvailable("signed_off", "flow-atlas")).toBe(true);
  });

  it("should block reports for in-progress assessment", () => {
    expect(isReportAvailable("in_progress", "executive-summary")).toBe(false);
    expect(isReportAvailable("in_progress", "gap-register")).toBe(false);
  });

  it("should always allow audit trail", () => {
    expect(isReportAvailable("in_progress", "audit-trail")).toBe(true);
    expect(isReportAvailable("draft", "audit-trail")).toBe(true);
  });
});

// ===========================================================================
// XML Escape Tests
// ===========================================================================

describe("XML Escaping", () => {
  it("should escape ampersand", () => {
    expect(escapeXml("A & B")).toBe("A &amp; B");
  });

  it("should escape angle brackets", () => {
    expect(escapeXml("<test>")).toBe("&lt;test&gt;");
  });

  it("should escape quotes", () => {
    expect(escapeXml('say "hello"')).toBe("say &quot;hello&quot;");
  });

  it("should escape apostrophes", () => {
    expect(escapeXml("it's")).toBe("it&apos;s");
  });

  it("should handle multiple special characters", () => {
    expect(escapeXml("A & B < C > D")).toBe("A &amp; B &lt; C &gt; D");
  });

  it("should not modify clean strings", () => {
    expect(escapeXml("plain text")).toBe("plain text");
  });
});
