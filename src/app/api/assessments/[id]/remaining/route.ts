/** GET: List remaining items. POST: Add manual remaining item */

import { NextResponse, type NextRequest } from "next/server";
import { getCurrentUser } from "@/lib/auth/session";
import { isMfaRequired } from "@/lib/auth/permissions";
import { prisma } from "@/lib/db/prisma";
import { logDecision } from "@/lib/audit/decision-logger";
import { ERROR_CODES } from "@/types/api";
import { z } from "zod";


const CATEGORIES = [
  "unreviewed_step", "maybe_scope", "excluded_recommended_config",
  "out_of_scope_gap", "integration_point", "data_migration", "custom_requirement",
] as const;

const SEVERITIES = ["critical", "high", "medium", "low"] as const;

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
): Promise<NextResponse> {
  const user = await getCurrentUser();
  if (!user) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.UNAUTHORIZED, message: "Not authenticated" } },
      { status: 401 },
    );
  }

  if (isMfaRequired(user)) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.MFA_REQUIRED, message: "MFA verification required" } },
      { status: 403 },
    );
  }

  const { id: assessmentId } = await params;

  const assessment = await prisma.assessment.findUnique({
    where: { id: assessmentId, deletedAt: null },
    select: { id: true },
  });

  if (!assessment) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.NOT_FOUND, message: "Assessment not found" } },
      { status: 404 },
    );
  }

  const sp = request.nextUrl.searchParams;
  const where: Record<string, unknown> = { assessmentId };
  if (sp.get("category")) where.category = sp.get("category");
  if (sp.get("severity")) where.severity = sp.get("severity");
  if (sp.get("scopeItemId")) where.scopeItemId = sp.get("scopeItemId");
  if (sp.get("functionalArea")) where.functionalArea = sp.get("functionalArea");
  if (sp.get("resolved") === "true") where.resolvedAt = { not: null };
  else if (sp.get("resolved") === "false") where.resolvedAt = null;

  const items = await prisma.remainingItem.findMany({
    where,
    orderBy: [{ severity: "asc" }, { createdAt: "asc" }],
  });

  // Compute summary
  const allItems = await prisma.remainingItem.findMany({
    where: { assessmentId },
    select: { category: true, severity: true, resolvedAt: true },
  });

  const byCategory: Record<string, number> = {};
  const bySeverity: Record<string, number> = {};
  let resolved = 0;
  for (const item of allItems) {
    byCategory[item.category] = (byCategory[item.category] ?? 0) + 1;
    bySeverity[item.severity] = (bySeverity[item.severity] ?? 0) + 1;
    if (item.resolvedAt) resolved++;
  }

  return NextResponse.json({
    data: items,
    summary: {
      total: allItems.length,
      byCategory,
      bySeverity,
      resolved,
      unresolved: allItems.length - resolved,
    },
  });
}

const createSchema = z.object({
  category: z.enum(CATEGORIES),
  title: z.string().min(5).max(255),
  description: z.string().min(10).max(5000),
  severity: z.enum(SEVERITIES),
  scopeItemId: z.string().optional(),
  functionalArea: z.string().optional(),
  assignedTo: z.string().email().optional(),
});

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
): Promise<NextResponse> {
  const user = await getCurrentUser();
  if (!user) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.UNAUTHORIZED, message: "Not authenticated" } },
      { status: 401 },
    );
  }

  if (isMfaRequired(user)) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.MFA_REQUIRED, message: "MFA verification required" } },
      { status: 403 },
    );
  }

  const { id: assessmentId } = await params;

  const assessment = await prisma.assessment.findUnique({
    where: { id: assessmentId, deletedAt: null },
    select: { id: true },
  });

  if (!assessment) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.NOT_FOUND, message: "Assessment not found" } },
      { status: 404 },
    );
  }

  const body: unknown = await request.json();
  const parsed = createSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.VALIDATION_ERROR, message: parsed.error.issues[0]?.message ?? "Invalid input" } },
      { status: 400 },
    );
  }

  const item = await prisma.remainingItem.create({
    data: {
      assessmentId,
      category: parsed.data.category,
      title: parsed.data.title,
      description: parsed.data.description,
      severity: parsed.data.severity,
      scopeItemId: parsed.data.scopeItemId ?? null,
      functionalArea: parsed.data.functionalArea ?? null,
      assignedTo: parsed.data.assignedTo ?? null,
      autoGenerated: false,
    },
  });

  await logDecision({
    assessmentId,
    entityType: "remaining_item",
    entityId: item.id,
    action: "REMAINING_ITEM_ADDED",
    newValue: { category: item.category, title: item.title, severity: item.severity },
    actor: user.email,
    actorRole: user.role,
  });

  return NextResponse.json({ data: item }, { status: 201 });
}
