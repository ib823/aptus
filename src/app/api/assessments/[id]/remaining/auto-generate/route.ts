/** POST: Auto-generate remaining items from assessment data */

import { NextResponse, type NextRequest } from "next/server";
import { getCurrentUser } from "@/lib/auth/session";
import { isMfaRequired } from "@/lib/auth/permissions";
import { prisma } from "@/lib/db/prisma";
import { ERROR_CODES } from "@/types/api";

export const preferredRegion = "sin1";
export const maxDuration = 30;

export async function POST(
  _request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
): Promise<NextResponse> {
  const user = await getCurrentUser();
  if (!user) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.UNAUTHORIZED, message: "Not authenticated" } },
      { status: 401 },
    );
  }

  if (isMfaRequired(user)) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.MFA_REQUIRED, message: "MFA verification required" } },
      { status: 403 },
    );
  }

  const { id: assessmentId } = await params;

  const assessment = await prisma.assessment.findUnique({
    where: { id: assessmentId, deletedAt: null },
    select: { id: true },
  });

  if (!assessment) {
    return NextResponse.json(
      { error: { code: ERROR_CODES.NOT_FOUND, message: "Assessment not found" } },
      { status: 404 },
    );
  }

  // Get existing auto-generated items to avoid duplicates
  const existingItems = await prisma.remainingItem.findMany({
    where: { assessmentId, autoGenerated: true },
    select: { category: true, sourceEntityId: true },
  });
  const existingKeys = new Set(existingItems.map((i) => `${i.category}:${i.sourceEntityId}`));

  const itemsToCreate: Array<{
    assessmentId: string;
    category: string;
    title: string;
    description: string;
    severity: string;
    sourceEntityType: string;
    sourceEntityId: string;
    scopeItemId: string | null;
    functionalArea: string | null;
    autoGenerated: boolean;
  }> = [];

  // 1. Unreviewed steps
  const selections = await prisma.scopeSelection.findMany({
    where: { assessmentId, selected: true },
    select: { scopeItemId: true },
  });
  const selectedIds = selections.map((s) => s.scopeItemId);

  const allSteps = await prisma.processStep.findMany({
    where: { scopeItemId: { in: selectedIds } },
    select: { id: true, scopeItemId: true, actionTitle: true },
  });
  const respondedStepIds = new Set(
    (await prisma.stepResponse.findMany({
      where: { assessmentId },
      select: { processStepId: true },
    })).map((r) => r.processStepId),
  );

  // Get scope item areas for functional area assignment
  const scopeItems = await prisma.scopeItem.findMany({
    where: { id: { in: selectedIds } },
    select: { id: true, nameClean: true, functionalArea: true },
  });
  const scopeAreaMap = new Map(scopeItems.map((s) => [s.id, s.functionalArea]));
  const scopeNameMap = new Map(scopeItems.map((s) => [s.id, s.nameClean]));

  for (const step of allSteps) {
    if (!respondedStepIds.has(step.id) && !existingKeys.has(`unreviewed_step:${step.id}`)) {
      itemsToCreate.push({
        assessmentId,
        category: "unreviewed_step",
        title: `Unreviewed: ${step.actionTitle}`,
        description: `Process step "${step.actionTitle}" in scope item ${scopeNameMap.get(step.scopeItemId) ?? step.scopeItemId} has not been reviewed yet.`,
        severity: "medium",
        sourceEntityType: "process_step",
        sourceEntityId: step.id,
        scopeItemId: step.scopeItemId,
        functionalArea: scopeAreaMap.get(step.scopeItemId) ?? null,
        autoGenerated: true,
      });
    }
  }

  // 2. MAYBE scope items
  const maybeSelections = await prisma.scopeSelection.findMany({
    where: { assessmentId, relevance: "MAYBE" },
    select: { scopeItemId: true },
  });
  for (const sel of maybeSelections) {
    if (!existingKeys.has(`maybe_scope:${sel.scopeItemId}`)) {
      itemsToCreate.push({
        assessmentId,
        category: "maybe_scope",
        title: `Undecided: ${scopeNameMap.get(sel.scopeItemId) ?? sel.scopeItemId}`,
        description: `Scope item ${sel.scopeItemId} is marked as MAYBE and needs a final decision.`,
        severity: "high",
        sourceEntityType: "scope_item",
        sourceEntityId: sel.scopeItemId,
        scopeItemId: sel.scopeItemId,
        functionalArea: scopeAreaMap.get(sel.scopeItemId) ?? null,
        autoGenerated: true,
      });
    }
  }

  // 3. Excluded recommended configs
  const recommendedConfigs = await prisma.configActivity.findMany({
    where: { scopeItemId: { in: selectedIds }, category: "Recommended" },
    select: { id: true, scopeItemId: true, configItemName: true },
  });
  const excludedSelections = await prisma.configSelection.findMany({
    where: {
      assessmentId,
      configActivityId: { in: recommendedConfigs.map((c) => c.id) },
      included: false,
    },
    select: { configActivityId: true },
  });
  const excludedIds = new Set(excludedSelections.map((s) => s.configActivityId));

  for (const config of recommendedConfigs) {
    if (excludedIds.has(config.id) && !existingKeys.has(`excluded_recommended_config:${config.id}`)) {
      itemsToCreate.push({
        assessmentId,
        category: "excluded_recommended_config",
        title: `Excluded: ${config.configItemName}`,
        description: `Recommended configuration "${config.configItemName}" was excluded from scope item ${scopeNameMap.get(config.scopeItemId) ?? config.scopeItemId}.`,
        severity: "medium",
        sourceEntityType: "config_activity",
        sourceEntityId: config.id,
        scopeItemId: config.scopeItemId,
        functionalArea: scopeAreaMap.get(config.scopeItemId) ?? null,
        autoGenerated: true,
      });
    }
  }

  // 4. OUT_OF_SCOPE gaps
  const outOfScopeGaps = await prisma.gapResolution.findMany({
    where: { assessmentId, resolutionType: "OUT_OF_SCOPE" },
    select: { id: true, scopeItemId: true, gapDescription: true },
  });
  for (const gap of outOfScopeGaps) {
    if (!existingKeys.has(`out_of_scope_gap:${gap.id}`)) {
      itemsToCreate.push({
        assessmentId,
        category: "out_of_scope_gap",
        title: `Deferred: ${gap.gapDescription.slice(0, 80)}`,
        description: `Gap "${gap.gapDescription}" was marked as OUT_OF_SCOPE and needs to be addressed in a future phase.`,
        severity: "high",
        sourceEntityType: "gap",
        sourceEntityId: gap.id,
        scopeItemId: gap.scopeItemId,
        functionalArea: scopeAreaMap.get(gap.scopeItemId) ?? null,
        autoGenerated: true,
      });
    }
  }

  // Batch create
  let created = 0;
  const byCategory: Record<string, number> = {};
  if (itemsToCreate.length > 0) {
    const result = await prisma.remainingItem.createMany({ data: itemsToCreate });
    created = result.count;
    for (const item of itemsToCreate) {
      byCategory[item.category] = (byCategory[item.category] ?? 0) + 1;
    }
  }

  return NextResponse.json({
    generated: created,
    byCategory,
    skippedExisting: existingItems.length,
  });
}
